from flask import Flask, request, jsonify
from n_puzzle import NPuzzle
# Node class is used internally by NPuzzle, no need for direct import here usually
# from node import Node 
import copy
import sys
import io
import json
import base64

app = Flask(__name__)

@app.route('/solve', methods=['POST'])
def solve_puzzle():
    data = request.get_json()

    # --- Input Validation ---
    if not data or 'n' not in data or 'num_shuffles' not in data:
        return jsonify({'error': 'Missing n or num_shuffles in request'}), 400

    n = data['n']
    num_shuffles = data['num_shuffles']

    if not isinstance(n, int) or n <= 1:
        return jsonify({'error': 'Invalid value for n (must be integer > 1)'}), 400
    
    if not isinstance(num_shuffles, int) or num_shuffles < 0:
        return jsonify({'error': 'Invalid value for num_shuffles (must be non-negative integer)'}), 400


    # --- Solver Integration ---
    try:
        # 1. Create an NPuzzle instance
        solver = NPuzzle(n=n)

        # 2. Generate the start grid by shuffling the solved state
        # We need the solved state grid first
        solved_grid = solver.solution # Access the solution grid generated by __init__
        # Use the shuffle method to generate the start grid
        # Note: shuffle currently prints progress, captured by stdout redirect below
        print(f"Generating start grid with {num_shuffles} shuffles...")
        start_grid = solver.shuffle(num_shuffles, solved_grid)
        print("Start grid generated.")
        # Optional: Display generated start grid for debugging
        # solver.display(start_grid) 

        # Redirect stdout to capture solver progress print statements
        old_stdout = sys.stdout
        redirected_output = io.StringIO()
        sys.stdout = redirected_output

        # 3. Run the solve method with the generated start_grid
        goal_node = solver.solve(start_grid)

        # Restore stdout
        sys.stdout = old_stdout
        solver_output = redirected_output.getvalue() # Get solver's print output
        print("Solver Output:\n", solver_output) # Log solver output to Flask console

        # 4. Process and encode the solution path
        if goal_node:
            solution_path = solver.get_solution_path(goal_node)
            
            # Encode the solution path using JSON -> bytes -> Base64
            solution_json = json.dumps(solution_path)
            solution_bytes = solution_json.encode('utf-8')
            solution_base64 = base64.b64encode(solution_bytes).decode('utf-8')
            
            response = {
                'solution_base64': solution_base64,
                'moves': goal_node.g, 
                'solver_log': solver_output.strip().split('\n')[-1] 
            }
            return jsonify(response), 200
        else:
            # Handle case where no solution is found
            response = {
                'error': 'No solution found',
                'solver_log': solver_output.strip().split('\n')[-1] 
            }
            return jsonify(response), 422 # Unprocessable Entity

    except ValueError as e:
        # Handle errors like invalid N during NPuzzle initialization
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        # Catch unexpected errors
        import traceback
        traceback.print_exc() 
        return jsonify({'error': f'An unexpected error occurred: {str(e)}'}), 500


if __name__ == '__main__':
    # Note: For development only. Use a production WSGI server like Gunicorn in production.
    app.run(debug=True) 